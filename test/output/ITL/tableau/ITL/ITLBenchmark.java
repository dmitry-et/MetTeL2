//Modified
/**
 * This file is generated by MetTeL v2
 * which is designed and implemented
 * by Dmitry Tishkovsky.
 */
package ITL.tableau.ITL;


import java.io.BufferedWriter;
import java.io.File;
import java.io.FilenameFilter;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.lang.management.ThreadMXBean;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.Properties;
import java.util.Set;

import mettel.core.tableau.MettelGeneralTableauRule;
import mettel.core.tableau.MettelProverThread;
import mettel.core.tableau.MettelSimpleTableauManager;
import mettel.core.MettelCoreRuntimeException;
import mettel.util.MettelProblemFile;
import mettel.util.MettelProperties;

import org.antlr.runtime.ANTLRFileStream;
import org.antlr.runtime.ANTLRInputStream;
import org.antlr.runtime.CharStream;
import org.antlr.runtime.CommonTokenStream;
import org.antlr.runtime.RecognitionException;

import au.com.bytecode.opencsv.CSVWriter;
import ITL.language.ITL.ITLExpression;
import ITL.language.ITL.ITLFormula;
import ITL.language.ITL.ITLLexer;
import ITL.language.ITL.ITLParser;
import ITL.language.ITL.ITLProblemAnalyzer;
import ITL.language.ITL.ITLTableauObjectFactory;
import static mettel.util.MettelStrings.FILE_SEPARATOR;
public class ITLBenchmark{

    private static int total = 0;
    private static int started = 0;
    private static int finished = 0;
    private final static Runtime runtime = Runtime.getRuntime();
    private static int memoryExcess = 0;
    private final static int MAX_THREAD_TRIES = 10000;
    private static BufferedWriter out = null;
    private static File inDir = null;
    private static CharStream in = null;
    private static long timeOutMilliSeconds = 1000;
    private static CSVWriter csvOut = null;
    private static File systemInfoFile = null;
    private static LinkedHashSet<MettelGeneralTableauRule> calculus;
    private static int numberOfThreads = Runtime.getRuntime().availableProcessors() - 2 > 0 ? Runtime.getRuntime().availableProcessors() - 2 : 1;
    final private static CommonTokenStream tokens = new CommonTokenStream();
    final private static ITLParser parser = new ITLParser(tokens);
    final private static ThreadMXBean mxBean = ManagementFactory.getThreadMXBean();
    private static HashSet<MettelProverThread> threads = new HashSet<MettelProverThread>(numberOfThreads);
    private static Properties pStat = null;

    private final static String CSV_NOT_RELEVANT_FIELD = "N/A";
    final private static String PROBLEM_FILE_EXT = ".mtl";
    final private static String SYSTEM_INFO_FILE_EXT = ".info";
    final private static String MODEL_FILE_EXT = ".model";
    final private static String CONTRADICTION_FILE_EXT = ".contradiction";
    private static double NANO_TO_MILLI_SECONDS = 1000000.0;

    final private static class MtlFilter implements FilenameFilter{
        public boolean accept(File dir, String name){
            return name.endsWith(PROBLEM_FILE_EXT);
        }
    }
    final private static MtlFilter MTL_FILTER = new MtlFilter();
    final private static String[] csvHeader = {"File name", "Satisfiable", "Model's/Contradiction's file name", "User time(ms)", "Time-out", "Timestamp", "Allowed execution-time(ms)", "Number of threads", "System Information", "Error","point.total.variable.number", "point.total.connective.number", "point.total.variable.occurences", "point.total.variable.max-depth", "point.total.connective.occurences", "point.total.connective.max-depth", "point.function.occurences", "point.function.max-depth", "formula.total.variable.number", "formula.total.connective.number", "formula.total.variable.occurences", "formula.total.variable.max-depth", "formula.total.connective.occurences", "formula.total.connective.max-depth", "formula.false.occurences", "formula.false.max-depth", "formula.less.occurences", "formula.less.max-depth", "formula.pointEquality.occurences", "formula.pointEquality.max-depth", "formula.negation.occurences", "formula.negation.max-depth", "formula.diamond.occurences", "formula.diamond.max-depth", "formula.box.occurences", "formula.box.max-depth", "formula.at.occurences", "formula.at.max-depth", "formula.conjunction.occurences", "formula.conjunction.max-depth", "formula.disjunction.occurences", "formula.disjunction.max-depth", "formula.implication.occurences", "formula.implication.max-depth", "total.variable.occurences", "total.variable.max-depth", "total.variable.number", "total.connective.occurences", "total.connective.max-depth", "total.connective.number", "total.symbol.max-depth", "total.symbol.length"};
    
    @SuppressWarnings("deprecation")
    public static void main(String[] args) throws IOException{
        try{
            parseCommandLineArguments(args);
            File csvFile = new File(inDir + FILE_SEPARATOR + "ITL.csv");
            boolean fileExisted = false;
            if (csvFile.exists()){
                fileExisted = true;
            }
            csvOut = new CSVWriter(new FileWriter(csvFile, true));
            try{
                if (!fileExisted){
                    csvOut.writeNext(csvHeader);
                    csvOut.flush();
                }

                calculus = new LinkedHashSet<MettelGeneralTableauRule>();
                parseCalculus(calculus);

                String systemInfoFilePath = inDir + FILE_SEPARATOR + "system";
                systemInfoFile = getUniqueResultFile(systemInfoFilePath, SYSTEM_INFO_FILE_EXT);
                out = new BufferedWriter(new FileWriter(systemInfoFile));
                try{
                    MettelProperties prop = new MettelProperties();
                    prop.putAll(System.getProperties());
                    prop.store(out, "");
                }finally{out.close();}

                String[] problemFiles = inDir.list(MTL_FILTER);
                int indexProblemFile = 0;

                total = problemFiles.length;
                while (!threads.isEmpty() || indexProblemFile < total){
                    for (int i = threads.size(); i < numberOfThreads && indexProblemFile < total; i++){
                        if(threads.size() > 0 && runtime.freeMemory() < memoryExcess){
                            System.runFinalization();
                            System.gc();
                            break;
                        }
                        threads.add(createAndStartNewThread(problemFiles[indexProblemFile]));
                        indexProblemFile++;
                        Thread.sleep(0);
                    }
                    Thread.sleep(0);
                    Iterator<MettelProverThread> it = threads.iterator();
                    while (it.hasNext()){
                        MettelProverThread thread = it.next();
                        boolean threadFinished = false;
                        if (!thread.isAlive()){
                            final Boolean threadResult = thread.result();
                            finished++;
                            System.out.println("["+ finished + '/'+ total + ',' + (threads.size()-1) + ']' + thread.getName() + " completed, " + thread.time() + " ms, " + (threadResult == null ? (thread.exception() == null? "Unknown error": thread.exception()) : (threadResult ? "Satisfiable" : "Unsatisfiable")));
                            threadFinished = true;
                        }else{
                            long nanos = mxBean.getThreadUserTime(thread.getId());
                            if (nanos >= timeOutMilliSeconds * NANO_TO_MILLI_SECONDS){
                                thread.stop();
                                finished++;
                                System.out.println("["+ finished + '/'+ total + ',' + (threads.size()-1) + ']' + thread.getName()+" time-out");
                                threadFinished = true;
                            }
                        }
                        if (threadFinished){
                            System.runFinalization();
                            System.gc();
                            updateProblemFile(thread);
                            printToCSV(thread);
                            it.remove();
                        }
                    }
                }
            }finally{csvOut.close();}
        }catch(Exception e){
            System.out.println("Sorry! I detected an exceptional situation and terminate now.");
            System.out.println("If you can help me to avoid this situation in future, please look at my error output.");
            System.err.println("==Exception==========================");
            e.printStackTrace(System.err);
            System.err.println("=====================================");
            System.exit(-1);
        }
    }

    private static MettelProverThread createAndStartNewThread(String problemFile) throws IOException, RecognitionException, InterruptedException{
        for(int i = 0; i < MAX_THREAD_TRIES; i++){
            try{
                in = new ANTLRFileStream(inDir + FILE_SEPARATOR + problemFile);
                tokens.setTokenSource(new ITLLexer(in));
                ArrayList<ITLFormula> list = new ArrayList<ITLFormula>();
                parser.formulas(list);
                ITLTableauObjectFactory tfactory = new ITLTableauObjectFactory();
                MettelSimpleTableauManager m = new MettelSimpleTableauManager(tfactory, calculus, 
                		new mettel.core.tableau.MettelSimpleLIFOBranchSelectionStrategy(),
                		new ITLSmallModelAcceptor(new ArrayList<ITLExpression>(list)));
                MettelProverThread pt = new MettelProverThread(m, list, mxBean);
                pt.setName(problemFile);
                pt.start();
                if(i > 0) System.out.println();
                started++;
                System.out.println("["+ started + '/'+ total + ',' + (threads.size()+1) + ']' + problemFile + " started");
                return pt;
            }catch(OutOfMemoryError e){
                System.gc();
                if(i == 0) System.out.print(problemFile + " start failure #");
                for(int j = i; j > 0; j = j%10) System.out.print('\b');
                System.out.print(i+1);
                if(i == MAX_THREAD_TRIES - 1){ throw e; }
                System.runFinalization();
                System.gc();
                Thread.sleep(0);
            }
        }
        throw new MettelCoreRuntimeException("I never should be here!");
    }
    private static File getUniqueResultFile(String fileName, String ext){
        File uniqueFile = null;
        int index = 0;
        if ((uniqueFile = new File(fileName + ext)).exists()){
            while ((uniqueFile = new File(fileName + "_" + index + ext)).exists()){
                index++;
            }
            return uniqueFile;
        }else{
            return uniqueFile;
        }
    }

    private static void updateProblemFile(MettelProverThread thread) throws IOException, RecognitionException{
        String problemPath = new String(inDir + FILE_SEPARATOR + thread.getName());
        MettelProblemFile pFile = new MettelProblemFile(problemPath);
        if(!pFile.existsStatisticsProperties()){
            ITLProblemAnalyzer pAnalyzer = new ITLProblemAnalyzer(problemPath);
            pStat = pAnalyzer.getStatistics();
            pFile.setStatisticsProperties(pStat);
        }else{
            pStat = pFile.getStatisticsProperties();
        }
        pFile.addStatusProperty("ITLProver", thread.result() == null? CSV_NOT_RELEVANT_FIELD: (thread.result()? "Satisfiable":"Unsatisfiable"));
        pFile.writeToFile();
    }

    private static void printToCSV(MettelProverThread thread) throws IOException{
        String[] problemInfo = new String[csvHeader.length];
        problemInfo[0] = inDir + FILE_SEPARATOR + thread.getName();

        SimpleDateFormat sdf = new SimpleDateFormat("dd-MM-yyyy HH:mm:ss");
        String formattedDate = sdf.format(new Date());
        problemInfo[5] = formattedDate;

        problemInfo[6] = String.valueOf(timeOutMilliSeconds);
        problemInfo[7] = String.valueOf(numberOfThreads);
        problemInfo[8] = systemInfoFile.toString();
        problemInfo[9] = thread.exception() == null ? CSV_NOT_RELEVANT_FIELD: thread.exception();

        if (thread.finished()){
            String resultFilePath = inDir + FILE_SEPARATOR + thread.getName().substring(0, thread.getName().length() - PROBLEM_FILE_EXT.length());
            File resultFile = null;
            String resultOutput = null;
            if (thread.model() != null){
                resultFile = getUniqueResultFile(resultFilePath, MODEL_FILE_EXT);
                resultOutput = thread.model().toString();
            }else{
                if(thread.contradiction() != null){
                    resultFile = getUniqueResultFile(resultFilePath, CONTRADICTION_FILE_EXT);
                    resultOutput = thread.contradiction().toString();
                }
            }
            if(resultFile != null){
                BufferedWriter resultOut = new BufferedWriter(new FileWriter(resultFile));
                try{
                    resultOut.write(resultOutput);
                }finally{
                    resultOut.close();
                }
            }

            problemInfo[1] = thread.result() == null? CSV_NOT_RELEVANT_FIELD: String.valueOf(thread.result());
            problemInfo[2] = resultFile == null ? CSV_NOT_RELEVANT_FIELD:resultFile.toString();
            problemInfo[3] = String.valueOf(thread.time());
            problemInfo[4] = String.valueOf(false);
        }else{
            problemInfo[1] = CSV_NOT_RELEVANT_FIELD;
            problemInfo[2] = CSV_NOT_RELEVANT_FIELD;
            problemInfo[3] = CSV_NOT_RELEVANT_FIELD;
            problemInfo[4] = String.valueOf(true);
        }
        fillCsvStatistics(problemInfo);
        csvOut.writeNext(problemInfo);
        csvOut.flush();
    }
    private static void fillCsvStatistics(String[] problemInfo){
        problemInfo[10] = pStat.getProperty("point.total.variable.number");
        problemInfo[11] = pStat.getProperty("point.total.connective.number");
        problemInfo[12] = pStat.getProperty("point.total.variable.occurences");
        problemInfo[13] = pStat.getProperty("point.total.variable.max-depth");
        problemInfo[14] = pStat.getProperty("point.total.connective.occurences");
        problemInfo[15] = pStat.getProperty("point.total.connective.max-depth");
        problemInfo[16] = pStat.getProperty("point.function.occurences");
        problemInfo[17] = pStat.getProperty("point.function.max-depth");
        problemInfo[18] = pStat.getProperty("formula.total.variable.number");
        problemInfo[19] = pStat.getProperty("formula.total.connective.number");
        problemInfo[20] = pStat.getProperty("formula.total.variable.occurences");
        problemInfo[21] = pStat.getProperty("formula.total.variable.max-depth");
        problemInfo[22] = pStat.getProperty("formula.total.connective.occurences");
        problemInfo[23] = pStat.getProperty("formula.total.connective.max-depth");
        problemInfo[24] = pStat.getProperty("formula.false.occurences");
        problemInfo[25] = pStat.getProperty("formula.false.max-depth");
        problemInfo[26] = pStat.getProperty("formula.less.occurences");
        problemInfo[27] = pStat.getProperty("formula.less.max-depth");
        problemInfo[28] = pStat.getProperty("formula.pointEquality.occurences");
        problemInfo[29] = pStat.getProperty("formula.pointEquality.max-depth");
        problemInfo[30] = pStat.getProperty("formula.negation.occurences");
        problemInfo[31] = pStat.getProperty("formula.negation.max-depth");
        problemInfo[32] = pStat.getProperty("formula.diamond.occurences");
        problemInfo[33] = pStat.getProperty("formula.diamond.max-depth");
        problemInfo[34] = pStat.getProperty("formula.box.occurences");
        problemInfo[35] = pStat.getProperty("formula.box.max-depth");
        problemInfo[36] = pStat.getProperty("formula.at.occurences");
        problemInfo[37] = pStat.getProperty("formula.at.max-depth");
        problemInfo[38] = pStat.getProperty("formula.conjunction.occurences");
        problemInfo[39] = pStat.getProperty("formula.conjunction.max-depth");
        problemInfo[40] = pStat.getProperty("formula.disjunction.occurences");
        problemInfo[41] = pStat.getProperty("formula.disjunction.max-depth");
        problemInfo[42] = pStat.getProperty("formula.implication.occurences");
        problemInfo[43] = pStat.getProperty("formula.implication.max-depth");
        problemInfo[44] = pStat.getProperty("total.variable.occurences");
        problemInfo[45] = pStat.getProperty("total.variable.max-depth");
        problemInfo[46] = pStat.getProperty("total.variable.number");
        problemInfo[47] = pStat.getProperty("total.connective.occurences");
        problemInfo[48] = pStat.getProperty("total.connective.max-depth");
        problemInfo[49] = pStat.getProperty("total.connective.number");
        problemInfo[50] = pStat.getProperty("total.symbol.max-depth");
        problemInfo[51] = pStat.getProperty("total.symbol.length");
    }

    private static void parseCommandLineArguments(String[] args) throws IOException{
        final int SIZE = args.length;
        for(int i = 0; i < SIZE; i++){
            if("-d".equals(args[i])||"--directory".equals(args[i])){
                if(i < SIZE-1){
                    inDir = new File(args[++i]);
                    System.out.println("Input directory: " + args[i]);
                }else{
                    System.out.println("I need a name of directory with problem files.");
                    System.exit(-1);
                }
            }else if("-t".equals(args[i])||"--timeout".equals(args[i])){
                if(i < SIZE-1){
                    timeOutMilliSeconds = Long.parseLong(args[++i]);
                    if(timeOutMilliSeconds < 0)  timeOutMilliSeconds *= -1;
                    System.out.println("Timeout: " + timeOutMilliSeconds + " ms");
                }else{
                    System.out.println("I need a number which specifies timeout.");
                    System.exit(-1);
                }
            }else if("-n".equals(args[i])||"--number-of-threads".equals(args[i])){
                if(i < SIZE-1){
                    numberOfThreads = Integer.parseInt(args[++i]);
                    if(numberOfThreads < 0) numberOfThreads *= -1;
                    System.out.println("Number of threads: " + numberOfThreads);
                }else{
                    System.out.println("I need a number which specifies number of threads.");
                    System.exit(-1);
                }
            }else if("-me".equals(args[i])||"--memory-excess".equals(args[i])){
                if(i < SIZE-1){
                    memoryExcess = Integer.parseInt(args[++i]);
                    if(memoryExcess < 0) memoryExcess *= -1;
                    System.out.println("Memory excess: " + memoryExcess +  " m");
                }else{
                    System.out.println("I need a number which specifies the memory excess.");
                    System.exit(-1);
                }
            }
        }
        if (inDir == null){
            System.out.println("You must provide input directory.");
            System.exit(-1);
        }
        if (!inDir.isDirectory()){
            System.out.println("Provided input is not a directory.");
            System.exit(-1);
        }
    }

    public static void parseCalculus(Set<MettelGeneralTableauRule> calculus) throws IOException, RecognitionException{
        CharStream tin = new ANTLRInputStream(ITLBenchmark.class.getResourceAsStream("calculus"));
        tokens.setTokenSource(new ITLLexer(tin));
        parser.tableauCalculus(calculus);
    }
}
